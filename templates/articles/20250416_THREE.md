---
id: 25
title: "OpenGL vs WebGL vs Three.js"
subtitle: "그래픽 렌더링 기술의 계층적 이해"
date: "2025.04.15"
thumbnail: ""
---
#

3D 그래픽 기술은 현대 웹과 애플리케이션 개발에서 필수적인 요소가 되었습니다. 게임, 시뮬레이션, 데이터 시각화, 가상현실 등 다양한 분야에서 활용되고 있으며, 이러한 그래픽 기술을 구현하기 위한 여러 도구와 라이브러리가 존재합니다. 그 중에서도 OpenGL, WebGL, Three.js는 각각 다른 추상화 수준과 사용 환경을 가진 대표적인 그래픽 기술입니다. 이 글에서는 이 세 기술의 관계와 차이점을 상세히 알아보겠습니다.

#
## 계층 구조로 이해하기
#
---
#
그래픽 렌더링 기술은 마치 피라미드와 같은 계층 구조를 가지고 있습니다. 가장 기초적이고 저수준의 기술부터 개발자 친화적인 고수준 기술까지 다양한 층위가 존재합니다. 이 세 기술은 다음과 같은 계층 구조로 이해할 수 있습니다:

```
OpenGL > OpenGL ES > WebGL > Three.js
(저수준)                      (고수준)
```

각 단계가 올라갈수록 개발자 친화적이고 추상화된 API를 제공합니다.
#
## OpenGL (Open Graphics Library)
#
---
#
![OpenGL 로고](https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F9skuxmwzbu9vj9ge4hjy.png){:height="200px"}

- **정의**: 1992년 실리콘 그래픽스사에서 제작한 2D/3D 그래픽 처리 라이브러리
- **기반 언어**: C언어
- **특징**:
    - GPU를 이용한 하드웨어 가속화를 통해 렌더링 수행
    - 저수준 그래픽 API로 직접적인 하드웨어 제어 가능
    - 데스크톱 애플리케이션, 게임 개발, 가상현실 등에 주로 사용
- **관리 주체**: 그로노스 그룹(Khronos Group)이라는 비영리 산업체 컨소시엄
#
## WebGL (Web Graphics Library)
#
---
#
![WebGL 로고](https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7r8t2mtsi0yy9yll1dm2.png){:height="200px"}

- **정의**: OpenGL ES 2.0에서 파생된 웹 환경의 그래픽 라이브러리
- **기반 언어**: JavaScript
- **특징**:
    - HTML Canvas 요소에 2D/3D 그래픽을 렌더링
    - 웹 브라우저에서 GPU 가속을 활용한 그래픽 처리 가능
    - OpenGL의 웹 버전이라고 생각할 수 있음
    - 모든 OpenGL 기능을 지원하지는 않음 (geometry shaders, tessellation shaders 등 제한)


- **작동 방식**:
    1. Canvas API로 WebGL Context를 가져옴
    2. 정점 셰이더와 색상 셰이더 코드를 작성해 WebGL Context로 전달
    3. GPU 프로세스에서 렌더링 파이프라인에 따라 픽셀 계산
    4. 계산된 픽셀값이 Canvas에 렌더링
#
## Three.js
#
---
#
![Three.js 로고](https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fgmvzs8zqwi1w05asjw0j.png){:height="200px"}

- **정의**: WebGL을 더 쉽게 사용할 수 있도록 만든 JavaScript 라이브러리
    - **특징**:
        - WebGL의 복잡한 API를 추상화하여 사용하기 쉽게 만듦
        - 영화 제작과 유사한 개념(씬, 카메라, 오브젝트)으로 3D 그래픽을 구성
        - 적은 코드로 복잡한 3D 시각화 구현 가능
        - 활성화된 커뮤니티와 풍부한 레퍼런스

- **작동 방식**:
    1. 씬(Scene) 인스턴스 생성
    2. 장면에 넣을 물체(Mesh) 인스턴스 생성 (Geometry + Material)
    3. 렌더러를 생성 후 카메라에 담긴 씬을 렌더링
#
## 쉬운 비유로 이해하기
#
---
#
이 세 기술의 관계를 자동차에 비유해보면:

- **OpenGL**: 자동차의 엔진과 변속기
    - 직접 만지려면 전문적인 지식 필요
    - 최대 성능과 유연성 제공

- **WebGL**: 자동차의 핸들과 페달 시스템
    - 엔진과 변속기를 제어하는 방법 제공
    - 직접 다루기는 여전히 복잡함

- **Three.js**: 자동차의 내비게이션과 자동 주행 시스템
    - 복잡한 기능을 단순한 인터페이스로 제공
    - 소프트웨어가 많은 복잡한 작업을 자동화
#
## 코드 비교
#
---
#
각 기술로 간단한 3D 큐브를 렌더링하는 경우:
#
**OpenGL(C++)**: 수백 줄의 코드 필요
```cpp
// 수백 줄의 복잡한 C++ 코드 필요
```
#
**WebGL(순수 JavaScript)**: 100줄 이상의 코드 필요
```javascript
// 100줄 이상의 JavaScript 코드와 GLSL 셰이더 코드 필요
```
#
**Three.js**: 약 20줄의 코드로 구현 가능
```javascript
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry();
const material = new THREE.MeshBasicMaterial({color: 0x00ff00});
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```
#
## 요약: 세 기술의 주요 차이점
#
---
#
| 특성 | OpenGL |# WebGL | Three.js |
|------|--------|-------|----------|
| 언어 | C/C++ | JavaScript | JavaScript |
| 환경 | 데스크톱 앱 | 웹 브라우저 | 웹 브라우저 |
| 추상화 수준 | 저수준 | 중간 수준 | 고수준 |
| 학습 난이도 | 매우 높음 | 높음 | 중간 |
| 기능 범위 | 매우 넓음 | 제한적 | WebGL 기반 |
| 코드 복잡성 | 매우 복잡 | 복잡 | 상대적으로 단순 |
| 개발 속도 | 느림 | 중간 | 빠름 |

결론적으로, 각 기술은 다른 목적과 사용 사례에 최적화되어 있습니다. OpenGL은 최대 성능과 제어를 원할 때, WebGL은 웹에서 직접적인 그래픽 제어가 필요할 때, Three.js는 웹에서 빠르고 효율적으로 3D 그래픽을 구현하고 싶을 때 사용하는 것이 적합합니다.